#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
File System Watcher - Monitors a drop folder for new files.

When files are added to the Inbox folder, this watcher copies them to
Needs_Action and creates accompanying metadata files for AI processing.

This is the simplest watcher to set up - just drop files into the Inbox!

Usage:
    python filesystem_watcher.py /path/to/vault

Features:
    - Monitors Inbox folder for new files
    - Copies files to Needs_Action with metadata
    - Supports all file types (documents, images, etc.)
    - Creates markdown metadata files with file info
"""

import sys
import shutil
import hashlib
from pathlib import Path
from datetime import datetime
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileCreatedEvent

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))
from base_watcher import BaseWatcher


class DropFolderHandler(FileSystemEventHandler):
    """Handle file system events for the drop folder."""
    
    def __init__(self, vault_path: Path, logger):
        self.vault_path = vault_path
        self.needs_action = vault_path / 'Needs_Action'
        self.inbox = vault_path / 'Inbox'
        self.logger = logger
        self.processed_files: set = set()
    
    def on_created(self, event):
        """Handle file creation events."""
        if event.is_directory:
            return
        
        source = Path(event.src_path)
        
        # Skip hidden files and temporary files
        if source.name.startswith('.') or source.name.endswith('.tmp'):
            return
        
        # Skip if already processed
        file_hash = self._file_hash(source)
        if file_hash in self.processed_files:
            return
        
        self.logger.info(f'New file detected: {source.name}')
        
        try:
            # Process the file
            self.process_file(source)
            self.processed_files.add(file_hash)
        except Exception as e:
            self.logger.error(f'Error processing file {source.name}: {e}')
    
    def _file_hash(self, filepath: Path) -> str:
        """Calculate MD5 hash of file for deduplication."""
        try:
            hash_md5 = hashlib.md5()
            with open(filepath, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_md5.update(chunk)
            return hash_md5.hexdigest()
        except Exception:
            return str(filepath)
    
    def process_file(self, source: Path):
        """
        Process a new file: copy to Needs_Action and create metadata.
        
        Args:
            source: Path to the source file
        """
        timestamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        dest_name = f'FILE_DROP_{timestamp}_{source.name}'
        dest = self.needs_action / dest_name
        
        # Copy the file
        shutil.copy2(source, dest)
        self.logger.info(f'Copied to: {dest}')
        
        # Create metadata file
        self.create_metadata(source, dest)
    
    def create_metadata(self, source: Path, dest: Path):
        """
        Create a markdown metadata file for the dropped file.
        
        Args:
            source: Original file path
            dest: Destination file path in Needs_Action
        """
        stat = source.stat()
        file_size = stat.st_size
        
        # Determine file type
        file_type = source.suffix.lower().replace('.', '')
        
        metadata_path = dest.with_suffix('.md')
        content = f'''---
type: file_drop
original_name: {source.name}
file_type: {file_type}
size: {file_size}
size_human: {self._human_readable_size(file_size)}
dropped_at: {datetime.now().isoformat()}
status: pending
---

# File Drop for Processing

## File Information

- **Original Name:** {source.name}
- **File Type:** {file_type.upper()}
- **Size:** {self._human_readable_size(file_size)}
- **Dropped At:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **Location:** `{dest.name}`

## Suggested Actions

- [ ] Review file content
- [ ] Categorize file
- [ ] Take appropriate action
- [ ] Move to /Done when complete

## Notes

*Add any notes or context for processing this file.*

---
*Automatically generated by File System Watcher*
'''
        
        metadata_path.write_text(content)
        self.logger.info(f'Created metadata: {metadata_path.name}')
    
    def _human_readable_size(self, size: int) -> str:
        """Convert bytes to human-readable format."""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024:
                return f'{size:.1f} {unit}'
            size /= 1024
        return f'{size:.1f} TB'


class FileSystemWatcher(BaseWatcher):
    """
    File System Watcher using watchdog library.
    
    Monitors the Inbox folder for new files and processes them.
    """
    
    def __init__(self, vault_path: str, check_interval: int = 5):
        """
        Initialize the file system watcher.
        
        Args:
            vault_path: Path to the Obsidian vault
            check_interval: Check interval (not used with watchdog, but kept for API compatibility)
        """
        super().__init__(vault_path, check_interval)
        self.inbox = self.vault_path / 'Inbox'
        
        # Ensure inbox folder exists
        self.inbox.mkdir(parents=True, exist_ok=True)
    
    def check_for_updates(self) -> list:
        """
        This method is not used with watchdog (event-driven).
        Included for API compatibility with BaseWatcher.
        
        Returns:
            list: Empty list (watchdog handles events directly)
        """
        return []
    
    def create_action_file(self, item) -> Path:
        """
        This method is not used with watchdog (event-driven).
        Included for API compatibility with BaseWatcher.
        
        Args:
            item: Not used
        
        Returns:
            Path: None
        """
        return Path()
    
    def run(self):
        """
        Run the file system watcher using watchdog Observer.
        
        This overrides the base class run() to use event-driven approach
        instead of polling.
        """
        self.logger.info(f'Starting FileSystemWatcher')
        self.logger.info(f'Watching folder: {self.inbox}')
        
        # Create the event handler
        event_handler = DropFolderHandler(self.vault_path, self.logger)
        
        # Create and start the observer
        observer = Observer()
        observer.schedule(event_handler, str(self.inbox), recursive=False)
        observer.start()
        
        self.logger.info('File System Watcher started. Drop files into /Inbox folder.')
        
        try:
            while True:
                # Keep the main thread alive
                import time
                time.sleep(1)
        except KeyboardInterrupt:
            self.logger.info('FileSystemWatcher stopped by user')
            observer.stop()
        except Exception as e:
            self.logger.error(f'Fatal error: {e}')
            observer.stop()
        
        observer.join()


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: python filesystem_watcher.py <vault_path>")
        print("\nExample:")
        print("  python filesystem_watcher.py /path/to/AI_Employee_Vault")
        sys.exit(1)
    
    vault_path = sys.argv[1]
    
    if not Path(vault_path).exists():
        print(f"Error: Vault path does not exist: {vault_path}")
        sys.exit(1)
    
    watcher = FileSystemWatcher(vault_path)
    watcher.run()


if __name__ == '__main__':
    main()
